# shell

以#！/bin/bash为第一行

## 变量

- 定义变量时，不加$符号
  
  变量命名只能以字母数字下划线，首个字符不能以数字开头

中间不能有空格，可以使用下划线，不能使用标点符号

不能使用bash里的关键字

- 使用一个定义过的变量，只要在变量名前加上$美元符号即可

变量名外面的{}可选加，最好加上。

- 只读变量
  
   readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

- 删除变量

使用 unset 命令可以删除变量。
```
unset variable_name
```
变量被删除后不能再次使用。unset 命令不能删除只读变量。

## 变量类型

运行shell时，会同时存在三种变量：
- **局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

## shell字符串

字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。

### 单引号
```
str='this is a string'
```
单引号字符串的限制：
- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

### 双引号
```
name="mike"
str="hello ,i know you are \"$name\"! \n"
echo -e $str
```

## shell 传递参数

在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……
```
$    传给脚本的参数个数 #echo $0   #脚本本身的名字,执行这个脚本的命令

$1   传递给该shell脚本的第一个参数

$@   传给脚本的所有参数的列表

$$  脚本运行的当前进程ID号

$!  Shell最后运行的后台Process的PID(后台运行的最后一个进程的 进程ID号)

$?    最后运行的命令的结束代码（返回值）即执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)

$-    显示shell使用的当前选项，与set命令功能相同

$*    所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数，此选项参数可超过9个。

$#    添加到Shell的参数个数
```

## 正则表达式与通配符

-正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。

-通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。

grep，擅长单纯的查找或匹配文本内容；
```
grep -nr "a word"       非全词匹配
grep -nwr "words"       全词匹配
```

sed，擅长文本编辑，处理匹配到的文本内容；

一行一行读取文件内容并按照要求进行处理，把处理后的结果输出到屏幕

sed 不会修改原文件

awk，适合格式化文本文件，对文本文件进行更复杂的加工处理、分析

## while

shell中使用while循环

```
while true; do
.
.
done

```


# shell 命令
```
set -e
set +e
```
在接下来执行的命令中，如果命令的返回值不为0，那么会使所在的进程或shell退出;
在接下来执行的命令中，遇到命令的返回值不为0，会继续执行。

```
set -x 
set +x 
```
默认脚本执行情况下，屏幕只显示运行结果，没有其他内容，如果多个命令连续执行，运行结果就会连续输出，分不清楚哪行命令的执行与结果

set -x 用来在显示运行结果之前，先输出执行的那条命令

```
sort -u test1
```

将test1排序后删掉重复行

